############################################################################################################
#	World Ablaze AI mod - Priority Construction System - Core Module
#	Project management system: queue, factory assignment, progress tracking, completion
############################################################################################################

######################################################
# 	priority construction AI - Core System
######################################################

WA_AI_PC_set_global_variables = {

	### BUILDING CONSTRUCTION COSTS

	set_variable = { global.WA_AI_PC_BUILDING_RAILWAY_COST          = 800 }
	set_variable = { global.WA_AI_PC_BUILDING_INFRASTRUCTURE_COST   = 3000 }
	set_variable = { global.WA_AI_PC_BUILDING_AIRBASE_COST          = 500 }
	set_variable = { global.WA_AI_PC_BUILDING_ANTIAIR_COST          = 1200 }
	set_variable = { global.WA_AI_PC_BUILDING_RADAR_COST            = 2000 }
	set_variable = { global.WA_AI_PC_BUILDING_MILITARY_FACTORY_COST = 7500 }
	set_variable = { global.WA_AI_PC_BUILDING_CIVILIAN_FACTORY_COST = 10000 }
	set_variable = { global.WA_AI_PC_BUILDING_DOCKYARD_COST         = 10000 }
	set_variable = { global.WA_AI_PC_BUILDING_REFINERY_COST         = 18000 }
	set_variable = { global.WA_AI_PC_CONVERSION_COST_MIL_TO_CIV     = 8000 }
	set_variable = { global.WA_AI_PC_CONVERSION_COST_CIV_TO_MIL     = 6800 }
	set_variable = { global.WA_AI_PC_BUILDING_HYDROPOWEREDSTEELMILL_COST         = 12500 }
	set_variable = { global.WA_AI_PC_BUILDING_HYDROPOWEREDALUMINIUMSMELTER_COST  = 12500 }
	set_variable = { global.WA_AI_PC_BUILDING_STEELMILL_COST                     = 10000 }
	set_variable = { global.WA_AI_PC_BUILDING_ALUMINIUMSMELTER_COST              = 10000 }
	set_variable = { global.WA_AI_PC_BUILDING_NAVAL_BASE_COST                    = 3000 }

	### BUILDING TYPE IDS
	set_variable = { global.WA_AI_PC_RAIL = 13 }
	set_variable = { global.WA_AI_PC_NAVAL_BASE = 14 }

	###

	every_country = {
		### Dynamic queue system (replaces fixed 5-slot array)
		# arr: WA_AI_PC_queue - dynamic queue of project IDs
		# arr: WA_AI_PC_target_state - project state targets indexed by project_id
		clear_array = WA_AI_PC_queue
		clear_array = WA_AI_PC_target_state

		# Initialize counters
		set_variable = { WA_AI_PC_active_projects = 0 }
		set_variable = { WA_AI_PC_assigned_factories_total = 0 }

		add_dynamic_modifier = { modifier = WA_AI_PC_project_assigned_factories_modifier }
	}
}

### Dynamic Queue System - Get new project ID
# Finds an unused project ID or creates a new one
# Output: new_project_ (temp variable)
WA_AI_PC_get_new_project_ID = {
	# Find first empty slot in target_state array (value = 0)
	set_temp_variable = { new_project_ = -1 }

	for_each_loop = { array = WA_AI_PC_target_state index = _idx value = _val break = _found_id
		if = { limit = { check_variable = { _val = 0 } }
			set_temp_variable = { new_project_ = _idx }
			set_temp_variable = { _found_id = 1 }
		}
	}

	# If no empty slot found, create new one at end
	if = { limit = { check_variable = { new_project_ = -1 } }
		set_temp_variable = { new_project_ = WA_AI_PC_target_state^num }
		add_to_array = { WA_AI_PC_target_state = 0 }
	}
}

### Dynamic Queue System - Get construction speed for a state
# THIS = state, _project_building_type >>> construction_speed_
WA_AI_PC_get_build_speed = {
	set_temp_variable = { construction_speed_ = 1 }

	# Add building type specific modifiers
	if = { limit = { check_variable = { _project_building_type = 1 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_infrastructure_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 2 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_air_base_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 3 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_anti_air_building_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 4 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_radar_station_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 5 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_arms_factory_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 6 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_industrial_complex_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 7 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_dockyard_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 8 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_synthetic_refinery_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 11 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_hydro_steel_refinery_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 12 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_hydro_aluminium_refinery_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 15 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_steel_refinery_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 16 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_aluminium_refinery_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 13 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_rail_way_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 14 } }
		add_to_temp_variable = { construction_speed_ = modifier@production_speed_naval_base_factor }
	}

	# Add general construction speed modifier
	add_to_temp_variable = { construction_speed_ = modifier@production_speed_buildings_factor }

	# Infrastructure effect for factory-type buildings (types 5-12, 15-16)
	if = { limit = { OR = { AND = { check_variable = { _project_building_type > 4 } check_variable = { _project_building_type < 13 } } check_variable = { _project_building_type = 15 } check_variable = { _project_building_type = 16 } } }
		set_temp_variable = { _infra_bonus = infrastructure_level }
		multiply_temp_variable = { _infra_bonus = 0.1 }
		add_to_temp_variable = { _infra_bonus = 1 }
		multiply_temp_variable = { construction_speed_ = _infra_bonus }
	}

	# Base output per factory per day
	multiply_temp_variable = { construction_speed_ = 2.5 }
}

### Dynamic Queue System - Get building cost
# THIS = state, _project_building_type, _project_province_id, _project_connect_id >>> building_cost_
WA_AI_PC_get_building_cost = {
	set_temp_variable = { building_cost_ = 0 }

	if = { limit = { check_variable = { _project_building_type = 1 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_INFRASTRUCTURE_COST }
		# Level price effect
		set_temp_variable = { _level_cost = infrastructure_level }
		multiply_temp_variable = { _level_cost = 100 }
		add_to_temp_variable = { building_cost_ = _level_cost }
	}
	else_if = { limit = { check_variable = { _project_building_type = 2 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_AIRBASE_COST }
		set_temp_variable = { _level_cost = building_level@air_base }
		multiply_temp_variable = { _level_cost = 250 }
		add_to_temp_variable = { building_cost_ = _level_cost }
	}
	else_if = { limit = { check_variable = { _project_building_type = 3 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_ANTIAIR_COST }
	}
	else_if = { limit = { check_variable = { _project_building_type = 4 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_RADAR_COST }
		set_temp_variable = { _level_cost = building_level@radar_station }
		multiply_temp_variable = { _level_cost = 500 }
		add_to_temp_variable = { building_cost_ = _level_cost }
	}
	else_if = { limit = { check_variable = { _project_building_type = 5 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_MILITARY_FACTORY_COST }
	}
	else_if = { limit = { check_variable = { _project_building_type = 6 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_CIVILIAN_FACTORY_COST }
	}
	else_if = { limit = { check_variable = { _project_building_type = 7 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_DOCKYARD_COST }
	}
	else_if = { limit = { check_variable = { _project_building_type = 8 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_REFINERY_COST }
	}
	else_if = { limit = { check_variable = { _project_building_type = 9 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_CONVERSION_COST_MIL_TO_CIV }
		set_temp_variable = { _conv_factor = modifier@conversion_cost_mil_to_civ_factor }
		add_to_temp_variable = { _conv_factor = 1.0 }
		multiply_temp_variable = { building_cost_ = _conv_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 10 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_CONVERSION_COST_CIV_TO_MIL }
		set_temp_variable = { _conv_factor = modifier@conversion_cost_civ_to_mil_factor }
		add_to_temp_variable = { _conv_factor = 1.0 }
		multiply_temp_variable = { building_cost_ = _conv_factor }
	}
	else_if = { limit = { check_variable = { _project_building_type = 11 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_HYDROPOWEREDSTEELMILL_COST }
	}
	else_if = { limit = { check_variable = { _project_building_type = 12 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_HYDROPOWEREDALUMINIUMSMELTER_COST }
	}
	else_if = { limit = { check_variable = { _project_building_type = 15 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_STEELMILL_COST }
	}
	else_if = { limit = { check_variable = { _project_building_type = 16 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_ALUMINIUMSMELTER_COST }
	}
	else_if = { limit = { check_variable = { _project_building_type = 13 } }
		# Railway cost: base + extra per existing level
		set_temp_variable = { building_cost_ = 170 }  # Base cost
		set_temp_variable = { _rail_level = 1 }
		meta_effect = {
			text = {
				add_to_temp_variable = { _rail_level = global.WA_AI_PC_railway_connection_level_[x]^[y] }
			}
			x = "[?_project_province_id]"
			y = "[?_project_connect_id]"
		}
		set_temp_variable = { _level_cost = 130 }
		multiply_temp_variable = { _level_cost = _rail_level }
		add_to_temp_variable = { building_cost_ = _level_cost }
	}
	else_if = { limit = { check_variable = { _project_building_type = 14 } }
		set_temp_variable = { building_cost_ = global.WA_AI_PC_BUILDING_NAVAL_BASE_COST }
	}
}

### Dynamic Queue System - Assign factories to projects
# THIS = country
# Allocates available factories to projects from the top of the queue
WA_AI_PC_assign_factories = {
	# Calculate available factories BEFORE resetting (add back currently assigned to get true available)
	set_temp_variable = { available_factories_ = num_of_civilian_factories_available_for_projects }
	add_to_temp_variable = { available_factories_ = WA_AI_PC_assigned_factories_total }

	if = { limit = { has_country_flag = WA_AI_construction_logging }
		log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC_ASSIGN: queue=[?WA_AI_PC_queue^num] raw_avail=[?available_factories_]"
	}

	# Check for override factor (e.g., during high-priority railway construction)
	if = { limit = { has_country_flag = WA_AI_PC_override_max_factories_factor }
		multiply_temp_variable = { available_factories_ = WA_AI_PC_override_max_factories_factor }
	}
	else = {
		multiply_temp_variable = { available_factories_ = 0.35 }
	}

	if = { limit = { has_country_flag = WA_AI_construction_logging }
		log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC_ASSIGN: after_35pct=[?available_factories_]"
	}

	# Reset all project factory assignments (use temp for new total)
	for_each_loop = { array = WA_AI_PC_queue value = _project_id
		set_variable = { WA_AI_PC_assigned_factories^_project_id = 0 }
	}
	set_temp_variable = { _new_total = 0 }

	# Sort queue by priority (descending - highest priority first)
	# Step 1: Build temp arrays for sorting
	clear_temp_array = _sort_ids_
	clear_temp_array = _sort_prios_
	for_each_loop = { array = WA_AI_PC_queue value = _project_id
		add_to_temp_array = { _sort_ids_ = _project_id }
		add_to_temp_array = { _sort_prios_ = WA_AI_PC_priority^_project_id }
	}

	# Step 2: Bubble sort descending (higher priority first)
	set_temp_variable = { _sort_n = _sort_ids_^num }
	set_temp_variable = { _sort_i = 0 }
	while_loop_effect = { limit = { check_variable = { _sort_i < _sort_n } }
		set_temp_variable = { _sort_j = _sort_i }
		add_to_temp_variable = { _sort_j = 1 }
		while_loop_effect = { limit = { check_variable = { _sort_j < _sort_n } }
			# Descending: swap if j > i (higher values should come first)
			if = { limit = { check_variable = { _sort_prios_^_sort_j > _sort_prios_^_sort_i } }
				# Swap priorities
				set_temp_variable = { _tmp_prio = _sort_prios_^_sort_i }
				set_temp_variable = { _sort_prios_^_sort_i = _sort_prios_^_sort_j }
				set_temp_variable = { _sort_prios_^_sort_j = _tmp_prio }
				# Swap IDs
				set_temp_variable = { _tmp_id = _sort_ids_^_sort_i }
				set_temp_variable = { _sort_ids_^_sort_i = _sort_ids_^_sort_j }
				set_temp_variable = { _sort_ids_^_sort_j = _tmp_id }
			}
			add_to_temp_variable = { _sort_j = 1 }
		}
		add_to_temp_variable = { _sort_i = 1 }
	}

	# Step 3: Rebuild queue in sorted order
	clear_array = WA_AI_PC_queue
	for_each_loop = { array = _sort_ids_ value = _sorted_id
		add_to_array = { WA_AI_PC_queue = _sorted_id }
	}

	if = { limit = { has_country_flag = WA_AI_construction_logging }
		log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC_ASSIGN: queue sorted by priority"
		# Log first 3 projects after sort to verify order
		if = { limit = { check_variable = { WA_AI_PC_queue^num > 0 } }
			set_temp_variable = { _dbg_p0 = WA_AI_PC_queue^0 }
			set_temp_variable = { _dbg_prio0 = WA_AI_PC_priority^_dbg_p0 }
			log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC_ASSIGN: [0] proj=[?_dbg_p0] prio=[?_dbg_prio0]"
		}
		if = { limit = { check_variable = { WA_AI_PC_queue^num > 1 } }
			set_temp_variable = { _dbg_p1 = WA_AI_PC_queue^1 }
			set_temp_variable = { _dbg_prio1 = WA_AI_PC_priority^_dbg_p1 }
			log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC_ASSIGN: [1] proj=[?_dbg_p1] prio=[?_dbg_prio1]"
		}
		if = { limit = { check_variable = { WA_AI_PC_queue^num > 2 } }
			set_temp_variable = { _dbg_p2 = WA_AI_PC_queue^2 }
			set_temp_variable = { _dbg_prio2 = WA_AI_PC_priority^_dbg_p2 }
			log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC_ASSIGN: [2] proj=[?_dbg_p2] prio=[?_dbg_prio2]"
		}
	}

	# Assign to projects from top of queue
	for_each_loop = { array = WA_AI_PC_queue value = _project_id break = _assign_break
		if = {
			limit = {
				check_variable = { available_factories_ > 0 }
				# Check state is still valid
				NOT = { check_variable = { WA_AI_PC_target_state^_project_id = 0 } }
				# Check progress remaining
				check_variable = { WA_AI_PC_progress^_project_id > 0 }
			}

			set_temp_variable = { assign_amount = available_factories_ }
			clamp_temp_variable = { var = assign_amount min = 1 max = 20 }
			round_temp_variable = assign_amount

			set_variable = { WA_AI_PC_assigned_factories^_project_id = assign_amount }
			add_to_temp_variable = { _new_total = assign_amount }
			subtract_from_temp_variable = { available_factories_ = assign_amount }

			if = { limit = { has_country_flag = WA_AI_construction_logging }
				set_temp_variable = { _dbg_state = WA_AI_PC_target_state^_project_id }
				set_temp_variable = { _dbg_prog = WA_AI_PC_progress^_project_id }
				log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC_ASSIGN: proj=[?_project_id] assigned=[?assign_amount] state=[?_dbg_state] prog=[?_dbg_prog]"
			}
		}
		else_if = {
			limit = { check_variable = { available_factories_ < 1 } }
			set_temp_variable = { _assign_break = 1 }
		}
		else = {
			# Log why project was skipped
			if = { limit = { has_country_flag = WA_AI_construction_logging }
				set_temp_variable = { _dbg_state = WA_AI_PC_target_state^_project_id }
				set_temp_variable = { _dbg_prog = WA_AI_PC_progress^_project_id }
				log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC_ASSIGN: SKIPPED proj=[?_project_id] state=[?_dbg_state] prog=[?_dbg_prog] avail=[?available_factories_]"
			}
		}
	}

	# Update total only once at the end, then force single modifier update
	set_variable = { WA_AI_PC_assigned_factories_total = _new_total }

	if = { limit = { has_country_flag = WA_AI_construction_logging }
		log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC_ASSIGN: TOTAL=[?WA_AI_PC_assigned_factories_total]"
	}

	force_update_dynamic_modifier = yes
}

### Dynamic Queue System - Update project progress
# THIS = country
# Called weekly to progress construction and complete finished projects
# Handles mid-week completions by reassigning freed factories immediately
WA_AI_PC_update_project_progress = {
	set_temp_variable = { _remaining_days = 7 }
	set_temp_variable = { _progress_iterations = 0 }

	# Cleanup pass: complete any stuck projects with progress <= 0 or cost = 0
	clear_temp_array = _cleanup_project_ids
	for_each_loop = { array = WA_AI_PC_queue value = _project_id
		if = {
			limit = {
				OR = {
					NOT = { check_variable = { WA_AI_PC_progress^_project_id > 0 } }
					NOT = { check_variable = { WA_AI_PC_project_cost^_project_id > 0 } }
				}
			}
			add_to_temp_array = { _cleanup_project_ids = _project_id }
		}
	}
	if = {
		limit = { check_variable = { _cleanup_project_ids^num > 0 } }
		for_each_loop = { array = _cleanup_project_ids value = _project_id
			if = { limit = { has_country_flag = WA_AI_construction_logging }
				set_temp_variable = { _dbg_prog = WA_AI_PC_progress^_project_id }
				set_temp_variable = { _dbg_cost = WA_AI_PC_project_cost^_project_id }
				log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC CLEANUP: proj=[?_project_id] prog=[?_dbg_prog] cost=[?_dbg_cost]"
			}
			WA_AI_PC_complete_project_by_id = yes
		}
		# Reassign factories after cleanup
		WA_AI_PC_assign_factories = yes
	}

	# Process the week in segments, reassigning factories when projects complete
	while_loop_effect = {
		limit = {
			check_variable = { _remaining_days > 0.1 }
			check_variable = { _progress_iterations < 10 }
		}
		add_to_temp_variable = { _progress_iterations = 1 }

		# Find the earliest completing project
		set_temp_variable = { _earliest_completion_days = 999 }
		set_temp_variable = { _earliest_completion_id = -1 }

		for_each_loop = { array = WA_AI_PC_queue value = _project_id
			if = {
				limit = {
					check_variable = { WA_AI_PC_assigned_factories^_project_id > 0 }
					check_variable = { WA_AI_PC_progress^_project_id > 0 }
				}

				# Get construction speed
				set_temp_variable = { _project_building_type = WA_AI_PC_building_type^_project_id }
				var:WA_AI_PC_target_state^_project_id = {
					WA_AI_PC_get_build_speed = yes
				}

				# Calculate days to completion for this project
				set_temp_variable = { _daily_progress = construction_speed_ }
				multiply_temp_variable = { _daily_progress = WA_AI_PC_assigned_factories^_project_id }

				if = { limit = { check_variable = { _daily_progress > 0 } }
					set_temp_variable = { _days_needed = WA_AI_PC_progress^_project_id }
					divide_temp_variable = { _days_needed = _daily_progress }

					# Check if this completes within remaining days and is earliest
					if = {
						limit = {
							NOT = { check_variable = { _days_needed > _remaining_days } }
							check_variable = { _days_needed < _earliest_completion_days }
						}
						set_temp_variable = { _earliest_completion_days = _days_needed }
						set_temp_variable = { _earliest_completion_id = _project_id }
					}
				}
			}
		}

		# Determine how many days to process this iteration
		if = { limit = { NOT = { check_variable = { _earliest_completion_id < 0 } } }
			# Process up to the completion point
			set_temp_variable = { _days_to_process = _earliest_completion_days }
		}
		else = {
			# No completions - process remaining days
			set_temp_variable = { _days_to_process = _remaining_days }
		}

		# Apply progress for _days_to_process to all active projects
		for_each_loop = { array = WA_AI_PC_queue value = _project_id
			if = {
				limit = {
					check_variable = { WA_AI_PC_assigned_factories^_project_id > 0 }
					check_variable = { WA_AI_PC_progress^_project_id > 0 }
				}

				set_temp_variable = { _project_building_type = WA_AI_PC_building_type^_project_id }
				var:WA_AI_PC_target_state^_project_id = {
					WA_AI_PC_get_build_speed = yes
				}

				set_temp_variable = { _segment_progress = construction_speed_ }
				multiply_temp_variable = { _segment_progress = WA_AI_PC_assigned_factories^_project_id }
				multiply_temp_variable = { _segment_progress = _days_to_process }
				subtract_from_variable = { WA_AI_PC_progress^_project_id = _segment_progress }

				# Update estimated build time
				if = { limit = { check_variable = { construction_speed_ > 0 } }
					set_variable = { WA_AI_PC_build_time^_project_id = WA_AI_PC_progress^_project_id }
					set_temp_variable = { _daily_speed = construction_speed_ }
					multiply_temp_variable = { _daily_speed = WA_AI_PC_assigned_factories^_project_id }
					if = { limit = { check_variable = { _daily_speed > 0 } }
						divide_variable = { WA_AI_PC_build_time^_project_id = _daily_speed }
					}
				}
			}
		}

		subtract_from_temp_variable = { _remaining_days = _days_to_process }

		# If a project completed, handle it and reassign factories
		if = { limit = { NOT = { check_variable = { _earliest_completion_id < 0 } } }
			set_temp_variable = { _project_id = _earliest_completion_id }
			WA_AI_PC_complete_project_by_id = yes
			WA_AI_PC_assign_factories = yes
		}
	}
}

### Dynamic Queue System - Complete project by ID
# _project_id >>> completes project and spawns building
WA_AI_PC_complete_project_by_id = {
	# Check if state is still controlled by us
	if = {
		limit = {
			NOT = { check_variable = { WA_AI_PC_target_state^_project_id = 0 } }
		}

		# Set project_type for the slot availability trigger
		set_variable = { WA_AI_PC_project_type = _project_id }

		# Check if this building type can be built in allied territory
		# Types: 1=infra, 2=airbase, 3=AA, 4=radar, 13=railway, 14=naval_base
		set_temp_variable = { _can_build_in_allied = 0 }
		if = {
			limit = {
				OR = {
					check_variable = { WA_AI_PC_building_type^_project_id = 1 }
					check_variable = { WA_AI_PC_building_type^_project_id = 2 }
					check_variable = { WA_AI_PC_building_type^_project_id = 3 }
					check_variable = { WA_AI_PC_building_type^_project_id = 4 }
					check_variable = { WA_AI_PC_building_type^_project_id = 13 }
					check_variable = { WA_AI_PC_building_type^_project_id = 14 }
				}
			}
			set_temp_variable = { _can_build_in_allied = 1 }
		}

		var:WA_AI_PC_target_state^_project_id = {
			# Strategic buildings (infra, airbase, AA, radar, railway) can be built in allied territory
			if = {
				limit = {
					check_variable = { _can_build_in_allied = 1 }
					CONTROLLER = {
						OR = {
							tag = ROOT
							is_in_faction_with = ROOT
							is_subject_of = ROOT
							ROOT = { is_subject_of = PREV }
						}
					}
					# Railways and naval_bases don't need slot check, others do
					OR = {
						check_variable = { ROOT.WA_AI_PC_building_type^_project_id = 13 }
						check_variable = { ROOT.WA_AI_PC_building_type^_project_id = 14 }
						WA_AI_PC_building_slot_available = yes
					}
				}

				# Spawn the building
				WA_AI_PC_add_finished_building_by_id = yes
			}
			# Factories and refineries require direct control
			else_if = {
				limit = {
					check_variable = { _can_build_in_allied = 0 }
					CONTROLLER = { tag = ROOT }
					WA_AI_PC_building_slot_available = yes
				}

				# Spawn the building
				WA_AI_PC_add_finished_building_by_id = yes
			}
		}

		WA_AI_PC_end_project_by_id = yes
	}
}

### Dynamic Queue System - End project by ID
# _project_id >>> removes project from queue and clears variables
WA_AI_PC_end_project_by_id = {
	# Remove from queue
	remove_from_array = { array = WA_AI_PC_queue value = _project_id }
	subtract_from_variable = { WA_AI_PC_active_projects = 1 }
	# Factory total is recalculated by WA_AI_PC_assign_factories after all completions

	# Remove from state tracking (per-country array stores project IDs)
	if = { limit = { NOT = { check_variable = { WA_AI_PC_target_state^_project_id = 0 } } }
		var:WA_AI_PC_target_state^_project_id = {
			remove_from_array = { array = WA_AI_PC_projects_in_state_of_@ROOT value = _project_id }
		}
	}

	# Clear project variables (mark slot as available by setting target_state to 0)
	set_variable = { WA_AI_PC_target_state^_project_id = 0 }
	clear_variable = WA_AI_PC_target_province^_project_id
	clear_variable = WA_AI_PC_connect_province^_project_id
	clear_variable = WA_AI_PC_project_cost^_project_id
	clear_variable = WA_AI_PC_progress^_project_id
	clear_variable = WA_AI_PC_building_type^_project_id
	clear_variable = WA_AI_PC_build_time^_project_id
	clear_variable = WA_AI_PC_priority^_project_id
	clear_variable = WA_AI_PC_assigned_factories^_project_id
	clear_variable = WA_AI_PC_type_id^_project_id
}

### Cancel multiple projects at once
# ROOT = BUILDER, _cancel_projects_IDS array (temp)
WA_AI_PC_cancel_projects = {
	for_each_loop = { array = _cancel_projects_IDS value = _project_id
		if = { limit = { has_country_flag = WA_AI_construction_logging }
			log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC CANCELLED: project_id=[?_project_id]"
		}
		WA_AI_PC_end_project_by_id = yes
	}
	clear_temp_array = _cancel_projects_IDS
}

### Validate queued provincial projects against current valid paths
# ROOT = BUILDER, _strategy_id (type_id to filter), _valid_provinces array (temp)
# Cancels any projects of the given strategy type whose target province is not in the valid paths
WA_AI_PC_validate_queued_provincial_projects = {
	clear_temp_array = _cancel_projects_IDS

	for_each_loop = { array = WA_AI_PC_queue value = _project_id
		if = {
			limit = {
				# Match the strategy type (railway = type_id 13)
				check_variable = { WA_AI_PC_type_id^_project_id = _strategy_id }
				# Project target province is NOT in the current valid paths
				NOT = { is_in_array = { _valid_provinces = WA_AI_PC_target_province^_project_id } }
			}
			add_to_temp_array = { _cancel_projects_IDS = _project_id }
		}
	}

	# Cancel invalid projects if any found
	if = { limit = { check_variable = { _cancel_projects_IDS^num > 0 } }
		if = { limit = { has_country_flag = WA_AI_construction_logging }
			log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC VALIDATION: Cancelling [?_cancel_projects_IDS^num] stale railway projects"
		}
		WA_AI_PC_cancel_projects = yes
	}

	# Clear input arrays
	clear_temp_array = _valid_provinces
}

### Dynamic Queue System - Add finished building by ID
# THIS = state, _project_id >>> spawns the building
WA_AI_PC_add_finished_building_by_id = {
	set_temp_variable = { _build_type = ROOT.WA_AI_PC_building_type^_project_id }

	if = { limit = { check_variable = { _build_type = 1 } }
		add_building_construction = { type = infrastructure level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 2 } }
		add_building_construction = { type = air_base level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 3 } }
		add_building_construction = { type = anti_air_building level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 4 } }
		add_building_construction = { type = radar_station level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 5 } }
		add_building_construction = { type = arms_factory level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 6 } }
		add_building_construction = { type = industrial_complex level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 7 } }
		add_building_construction = { type = dockyard level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 8 } }
		add_building_construction = { type = synthetic_refinery level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 9 } }
		remove_building = { type = arms_factory level = 1 }
		add_building_construction = { type = industrial_complex level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 10 } }
		remove_building = { type = industrial_complex level = 1 }
		add_building_construction = { type = arms_factory level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 11 } }
		add_building_construction = { type = hydro_steel_refinery level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 12 } }
		add_building_construction = { type = hydro_aluminium_refinery level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 15 } }
		add_building_construction = { type = steel_refinery level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 16 } }
		add_building_construction = { type = aluminium_refinery level = 1 instant_build = yes }
	}
	else_if = { limit = { check_variable = { _build_type = 13 } }
		# Railway construction using stored province data
		set_temp_variable = { _prov_from = ROOT.WA_AI_PC_target_province^_project_id }
		set_temp_variable = { _prov_to = ROOT.WA_AI_PC_connect_province^_project_id }

		meta_effect = {
			text = {
				build_railway = {
					level = 1
					path = { [x] [y] }
				}
				set_variable = { global.WA_AI_PC_railway_connections^[x] = 1 }
				add_to_variable = { global.WA_AI_PC_railway_connection_level_[x]^[y] = 1 }
				set_variable = { global.WA_AI_PC_railway_connections^[y] = 1 }
				add_to_variable = { global.WA_AI_PC_railway_connection_level_[y]^[x] = 1 }
			}
			x = "[?_prov_from]"
			y = "[?_prov_to]"
		}

		if = { limit = { ROOT = { has_country_flag = WA_AI_construction_logging } }
			ROOT = { log = "[GetYear] [GetMonth] | AI | [Root.GetName] | CONSTRUCTION: Railway built [?_prov_from] -> [?_prov_to]" }
		}
	}
	else_if = { limit = { check_variable = { _build_type = 14 } }
		# Naval base construction using stored province data
		set_temp_variable = { _port_prov = ROOT.WA_AI_PC_target_province^_project_id }

		meta_effect = {
			text = {
				add_building_construction = {
					type = naval_base
					level = 1
					province = { id = [PROV] }
					instant_build = yes
				}
			}
			PROV = "[?_port_prov]"
		}

		if = { limit = { ROOT = { has_country_flag = WA_AI_construction_logging } }
			ROOT = { log = "[GetYear] [GetMonth] | AI | [Root.GetName] | CONSTRUCTION: Naval base built at province [?_port_prov]" }
		}
	}
}

### projects

@AI_MAX_FRACTION_OF_FACTORIES_TO_ASSIGN_ON_PROJECTS_TOTAL = 0.35
@AI_MAX_FRACTION_OF_FACTORIES_TO_ASSIGN_ON_PROJECT = 0.15
@AI_MIN_NUM_OF_FACTORIES_TO_ASSIGN_ON_PROJECT = 20

### Dynamic Queue System - Start Project
# THIS = state, PREV = builder country
# Input: _project_building_type, _project_province_id, _project_connect_id,
#        _project_priority, _project_queue_num, _project_queue_max, _project_target_level, _project_type_id
# Creates projects and adds them to the dynamic queue
WA_AI_PC_start_project = {
	# Debug: log entry
	ROOT = { if = { limit = { has_country_flag = WA_AI_construction_logging }
		log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC START_PROJECT ENTRY: type=[?_project_building_type] state=[PREV.GetName] prov=[?_project_province_id]->[?_project_connect_id]"
	} }

	# Validate location is controlled
	if = {
		limit = {
			OR = {
				is_controlled_by = ROOT
				CONTROLLER = { is_in_faction_with = ROOT }
				CONTROLLER = { is_subject_of = ROOT }
			}
		}

		ROOT = {
			# Default queue_num to 1 if not set
			if = { limit = { check_variable = { _project_queue_num = 0 } }
				set_temp_variable = { _project_queue_num = 1 }
			}

			# Get current queued amount for this building type (for queue_max check)
			# Also check for province-level duplicates (naval bases, supply hubs, etc.)
			set_temp_variable = { queued_amount_ = 0 }
			set_temp_variable = { _province_already_queued = 0 }
			for_each_loop = { array = WA_AI_PC_queue value = _check_proj_id
				if = { limit = { check_variable = { WA_AI_PC_building_type^_check_proj_id = _project_building_type } }
					add_to_temp_variable = { queued_amount_ = 1 }
					# Check for province-level duplicate (same type + same province)
					if = {
						limit = {
							check_variable = { _project_province_id > 0 }
							check_variable = { WA_AI_PC_target_province^_check_proj_id = _project_province_id }
						}
						set_temp_variable = { _province_already_queued = 1 }
					}
				}
			}

			# Skip if this exact province is already queued for this building type
			if = { limit = { check_variable = { _province_already_queued = 1 } }
				if = { limit = { has_country_flag = WA_AI_construction_logging }
					log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC SKIP DUPLICATE: type=[?_project_building_type] prov=[?_project_province_id] already queued"
				}
			}
			else = {

			# Get current building level for target_level check (state-level buildings)
			set_temp_variable = { final_building_level_ = 0 }
			if = { limit = { check_variable = { _project_target_level > 0 } }
				PREV = {
					if = { limit = { check_variable = { _project_building_type = 1 } }
						set_temp_variable = { final_building_level_ = infrastructure_level }
					}
					else_if = { limit = { check_variable = { _project_building_type = 2 } }
						set_temp_variable = { final_building_level_ = building_level@air_base }
					}
					else_if = { limit = { check_variable = { _project_building_type = 4 } }
						set_temp_variable = { final_building_level_ = building_level@radar_station }
					}
				}
				# Add already queued projects to effective level
				add_to_temp_variable = { final_building_level_ = queued_amount_ }
			}

			# Create up to _project_queue_num projects
			while_loop_effect = { break = _start_project_break
				limit = {
					check_variable = { _project_queue_num > 0 }
					# Respect target level limit
					if = { limit = { check_variable = { _project_target_level > 0 } }
						check_variable = { final_building_level_ < _project_target_level }
					}
					# Respect queue max limit
					if = { limit = { check_variable = { _project_queue_max > 0 } }
						check_variable = { queued_amount_ < _project_queue_max }
					}
				}

				# Get new project ID
				WA_AI_PC_get_new_project_ID = yes
				set_temp_variable = { _project_id = new_project_ }

				# Get building cost
				PREV = { WA_AI_PC_get_building_cost = yes }

				# Set project variables
				# Use _project_target_state if provided (for railways), otherwise get from PREV scope
				if = { limit = { check_variable = { _project_target_state > 0 } }
					set_variable = { WA_AI_PC_target_state^_project_id = _project_target_state }
				}
				else = {
					# For state-level buildings called from state scope, get state ID via province mapping
					PREV = {
						set_temp_variable = { _temp_first_prov = global.WA_AI_MAP_state_province_ids@THIS^0 }
						set_temp_variable = { _project_target_state = global.WA_AI_MAP_province_state_id^_temp_first_prov }
					}
					set_variable = { WA_AI_PC_target_state^_project_id = _project_target_state }
				}
				set_variable = { WA_AI_PC_target_province^_project_id = _project_province_id }
				set_variable = { WA_AI_PC_connect_province^_project_id = _project_connect_id }
				set_variable = { WA_AI_PC_project_cost^_project_id = building_cost_ }
				set_variable = { WA_AI_PC_progress^_project_id = building_cost_ }
				set_variable = { WA_AI_PC_building_type^_project_id = _project_building_type }
				set_variable = { WA_AI_PC_priority^_project_id = _project_priority }
				set_variable = { WA_AI_PC_type_id^_project_id = _project_type_id }

				# Add to queue
				add_to_array = { WA_AI_PC_queue = _project_id }
				add_to_variable = { WA_AI_PC_active_projects = 1 }

				# Track in state (per-country array stores project IDs)
				PREV = {
					add_to_array = { WA_AI_PC_projects_in_state_of_@ROOT = _project_id }
				}

				# Update counters for next iteration
				add_to_temp_variable = { final_building_level_ = 1 }
				add_to_temp_variable = { queued_amount_ = 1 }
				subtract_from_temp_variable = { _project_queue_num = 1 }

				if = { limit = { has_country_flag = WA_AI_construction_logging }
					log = "[GetYear] [GetMonth] | AI | [Root.GetName] | PC QUEUED: type=[?_project_building_type] cost=[?building_cost_] state=[PREV.GetName] prov=[?_project_province_id]->[?_project_connect_id]"
				}
			}
		} # end else (not duplicate)
	} # end ROOT
	} # end if (controlled)
}

